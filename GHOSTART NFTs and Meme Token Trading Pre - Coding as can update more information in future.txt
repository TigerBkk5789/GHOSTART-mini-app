GHOSTART CODING

// GHOSTART Backend API - NFT Management System
// Environment: Node.js with Express
// Deploy to: Vercel, Heroku, or AWS Lambda

const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const crypto = require('crypto');

dotenv.config();

const app = express();
app.use(cors());
app.use(express.json());

// ============ Configuration ============

const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || 'GHOSTART2024';
const ADMIN_PASSWORD_HASH = crypto.createHash('sha256').update(ADMIN_PASSWORD).digest('hex');
const CREATOR_WALLET = '0x32f1e35291967c07ec02aa81394dbf87d1d25e52';
const CREATOR_ROYALTY = 10;

// In-memory database (use MongoDB/Firebase for production)
let nfts = [
  {
    id: 1,
    name: 'Ghost Rider #1',
    creator: 'GHOSTART',
    image: 'ğŸ‘»',
    wldPrice: 2.5,
    rarity: 'Rare',
    traits: ['Red Eyes', 'Fire Chain'],
    approved: true,
    listed: true,
    owner: null,
    createdAt: new Date(),
  },
  {
    id: 2,
    name: 'Flaming Skull #42',
    creator: 'GHOSTART',
    image: 'ğŸ’€',
    wldPrice: 5.0,
    rarity: 'Epic',
    traits: ['Glowing', 'Ancient'],
    approved: true,
    listed: true,
    owner: null,
    createdAt: new Date(),
  },
  {
    id: 3,
    name: 'Alien Punk #88',
    creator: 'GHOSTART',
    image: 'ğŸ‘½',
    wldPrice: 10.0,
    rarity: 'Legendary',
    traits: ['Holographic', 'Rare'],
    approved: true,
    listed: true,
    owner: null,
    createdAt: new Date(),
  },
  {
    id: 4,
    name: 'Glitch Spirit #7',
    creator: 'GHOSTART',
    image: 'âœ¨',
    wldPrice: 3.2,
    rarity: 'Rare',
    traits: ['Shimmer', 'Ethereal'],
    approved: true,
    listed: true,
    owner: null,
    createdAt: new Date(),
  },
];

let nextId = 5;
let pendingApprovals = [];

// ============ Middleware ============

const verifyAdmin = (req, res, next) => {
  const password = req.headers.authorization?.split(' ')[1];
  if (!password) {
    return res.status(401).json({ error: 'Missing admin password' });
  }
  
  const hash = crypto.createHash('sha256').update(password).digest('hex');
  if (hash !== ADMIN_PASSWORD_HASH) {
    return res.status(403).json({ error: 'Invalid admin password' });
  }
  
  next();
};

const validateWalletAddress = (address) => {
  return /^0x[a-fA-F0-9]{40}$/.test(address);
};

// ============ Public Routes ============

/**
 * GET /api/nfts
 * Get all approved and listed NFTs
 */
app.get('/api/nfts', (req, res) => {
  try {
    const approvedNFTs = nfts.filter(nft => nft.approved && nft.listed);
    res.json({
      success: true,
      data: approvedNFTs,
      count: approvedNFTs.length,
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * GET /api/nfts/:id
 * Get single NFT details
 */
app.get('/api/nfts/:id', (req, res) => {
  try {
    const nft = nfts.find(n => n.id === parseInt(req.params.id));
    if (!nft) {
      return res.status(404).json({ error: 'NFT not found' });
    }
    res.json({
      success: true,
      data: nft,
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * GET /api/nfts/owner/:address
 * Get NFTs owned by an address
 */
app.get('/api/nfts/owner/:address', (req, res) => {
  try {
    if (!validateWalletAddress(req.params.address)) {
      return res.status(400).json({ error: 'Invalid wallet address' });
    }

    const ownerNFTs = nfts.filter(
      nft => nft.owner && nft.owner.toLowerCase() === req.params.address.toLowerCase()
    );
    
    res.json({
      success: true,
      data: ownerNFTs,
      count: ownerNFTs.length,
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /api/nfts/list
 * List an NFT on marketplace (user must own it)
 */
app.post('/api/nfts/list', (req, res) => {
  try {
    const { nftId, owner, wldPrice } = req.body;

    if (!nftId || !owner || !wldPrice) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    if (!validateWalletAddress(owner)) {
      return res.status(400).json({ error: 'Invalid wallet address' });
    }

    if (wldPrice <= 0) {
      return res.status(400).json({ error: 'Price must be greater than 0' });
    }

    const nft = nfts.find(n => n.id === parseInt(nftId));
    if (!nft) {
      return res.status(404).json({ error: 'NFT not found' });
    }

    if (nft.owner && nft.owner.toLowerCase() !== owner.toLowerCase()) {
      return res.status(403).json({ error: 'You do not own this NFT' });
    }

    nft.owner = owner;
    nft.wldPrice = parseFloat(wldPrice);
    nft.listed = true;
    nft.approved = false; // Pending admin approval
    pendingApprovals.push({ nftId, owner, timestamp: new Date() });

    res.json({
      success: true,
      message: 'NFT listed for marketplace approval',
      data: nft,
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /api/nfts/mint
 * Mint a new NFT
 */
app.post('/api/nfts/mint', (req, res) => {
  try {
    const {
      name,
      image,
      wldPrice,
      rarity,
      traits,
      owner,
      creator,
    } = req.body;

    if (!name || !image || !wldPrice || !owner) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    if (!validateWalletAddress(owner)) {
      return res.status(400).json({ error: 'Invalid wallet address' });
    }

    const newNFT = {
      id: nextId++,
      name,
      creator: creator || 'User',
      image,
      wldPrice: parseFloat(wldPrice),
      rarity: rarity || 'Common',
      traits: traits || [],
      owner,
      approved: false, // Pending admin approval
      listed: false,
      createdAt: new Date(),
      contractAddress: CREATOR_WALLET,
      royalty: CREATOR_ROYALTY,
    };

    nfts.push(newNFT);
    pendingApprovals.push({ nftId: newNFT.id, action: 'mint', timestamp: new Date() });

    res.status(201).json({
      success: true,
      message: 'NFT minted successfully, pending admin approval',
      data: newNFT,
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * GET /api/stats
 * Get marketplace statistics
 */
app.get('/api/stats', (req, res) => {
  try {
    const totalNFTs = nfts.length;
    const approvedNFTs = nfts.filter(n => n.approved).length;
    const listedNFTs = nfts.filter(n => n.listed && n.approved).length;
    const pendingCount = pendingApprovals.length;
    const totalValue = nfts
      .filter(n => n.approved)
      .reduce((sum, n) => sum + n.wldPrice, 0);

    res.json({
      success: true,
      data: {
        totalNFTs,
        approvedNFTs,
        listedNFTs,
        pendingApprovals: pendingCount,
        totalMarketValue: totalValue.toFixed(2),
        creatorAddress: CREATOR_WALLET,
        creatorRoyalty: `${CREATOR_ROYALTY}%`,
      },
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ Admin Routes ============

/**
 * GET /api/admin/pending
 * Get all pending NFTs (admin only)
 */
app.get('/api/admin/pending', verifyAdmin, (req, res) => {
  try {
    const pending = nfts.filter(n => !n.approved);
    res.json({
      success: true,
      data: pending,
      count: pending.length,
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /api/admin/approve/:id
 * Approve an NFT (admin only)
 */
app.post('/api/admin/approve/:id', verifyAdmin, (req, res) => {
  try {
    const nft = nfts.find(n => n.id === parseInt(req.params.id));
    if (!nft) {
      return res.status(404).json({ error: 'NFT not found' });
    }

    nft.approved = true;
    pendingApprovals = pendingApprovals.filter(p => p.nftId !== nft.id);

    res.json({
      success: true,
      message: `NFT "${nft.name}" approved for marketplace`,
      data: nft,
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * DELETE /api/admin/nfts/:id
 * Remove an NFT (admin only)
 */
app.delete('/api/admin/nfts/:id', verifyAdmin, (req, res) => {
  try {
    const index = nfts.findIndex(n => n.id === parseInt(req.params.id));
    if (index === -1) {
      return res.status(404).json({ error: 'NFT not found' });
    }

    const removed = nfts.splice(index, 1)[0];
    pendingApprovals = pendingApprovals.filter(p => p.nftId !== removed.id);

    res.json({
      success: true,
      message: `NFT "${removed.name}" removed`,
      data: removed,
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * PUT /api/admin/nfts/:id
 * Edit an NFT (admin only)
 */
app.put('/api/admin/nfts/:id', verifyAdmin, (req, res) => {
  try {
    const nft = nfts.find(n => n.id === parseInt(req.params.id));
    if (!nft) {
      return res.status(404).json({ error: 'NFT not found' });
    }

    const { name, wldPrice, rarity, traits } = req.body;
    if (name) nft.name = name;
    if (wldPrice) nft.wldPrice = parseFloat(wldPrice);
    if (rarity) nft.rarity = rarity;
    if (traits) nft.traits = traits;

    res.json({
      success: true,
      message: 'NFT updated successfully',
      data: nft,
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * GET /api/admin/approvals
 * Get all pending approvals (admin only)
 */
app.get('/api/admin/approvals', verifyAdmin, (req, res) => {
  try {
    res.json({
      success: true,
      data: pendingApprovals,
      count: pendingApprovals.length,
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ Health Check ============

app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date() });
});

// ============ Error Handler ============

app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).json({ error: 'Internal server error' });
});

// ============ Server Start ============

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`ğŸš€ GHOSTART Backend running on port ${PORT}`);
  console.log(`ğŸ“ Staking Address: ${CREATOR_WALLET}`);
  console.log(`ğŸ’° Creator Royalty: ${CREATOR_ROYALTY}%`);
});

module.exports = app;




Fixed! I've removed the reference to the @worldcoin/idkit library. The World ID verification now uses a simulated approach that would work with the World ID API endpoints in production (via developer.worldcoin.org).
In a real implementation, you would:

Call the World ID Developer Portal API endpoints directly
Create verification sessions
Handle QR code generation for users to scan with World App
Verify proofs via the API

The current implementation shows the verification flow UI without requiring external libraries that aren't available in this environment.RetryTfixadding world chain wallet address for creator royalty 10%Â Wallet page must show NFTs storage and Token Staking amont and Token balanceGHOSTART - Enhanced NFT MarketplaceInteractive artifactâ€‚âˆ™â€‚Version 4Â Perfect! I've fixed both issues:
âœ… Changes Made:
1. Creator Royalty 10% with World Chain Address

Added CREATOR_WALLET constant with the World Chain whitelisted address: 0x32f1e35291967c07ec02aa81394dbf87d1d25e52
Set fixed CREATOR_ROYALTY to 10%
Display creator wallet address in the minting form
Made royalty field read-only (disabled) to show it's fixed at 10%

2. Enhanced Wallet Page

NFT Storage Dashboard: Shows total NFTs owned at a glance
Token Balance Display: Shows:

WLD Balance (main token)
Staked $GHOSTART amount
Available $GHOSTART for staking


Staking Features:

Input field for staking amount
Shows available balance based on WLD conversion
Tracks staked amount separately
Deducts from available balance when staked


Enhanced NFT Collection View:

Shows NFT value in WLD
Better visual hierarchy with colors
Grid layout for all owned NFTs



The wallet now provides a complete overview of the user's assets, storage, and staking position! ğŸ¯RetryTNFTs Listing Details : Title, Creator, WLD price, GHOSTART price (short as 1000 = 1 K GHOSTART)After Mint NFTs and appproved will be automaticly show at Marketplace page (GRID view 2 x 4 NFTS)Create Backend for Me (Owner Only for Remove and Editing) with code or passward.Create Smart Contract for Stake Token (GHOSTART)Â  - After Buy fromÂ  PUFÂ  and it will be have function for send token , Please Put information for Staking GHOSTART token to World Chain ADDRESSÂ  :Â Â 0x32f1e35291967c07ec02aa81394dbf87d1d25e52Â Pls make sure for navigator buttonÂ Localization byÂ  Â Solidityïƒ
Solidity is an object-oriented, high-level language for implementing smart contracts. Smart contracts are programs that govern the behavior of accounts within the Ethereum state.
Solidity is a curly-bracket language designed to target the Ethereum Virtual Machine (EVM). It is influenced by C++, Python, and JavaScript. You can find more details about which languages Solidity has been inspired by in the language influences section.
Solidity is statically typed, supports inheritance, libraries, and complex user-defined types, among other features.
With Solidity, you can create contracts for uses such as voting, crowdfunding, blind auctions, and multi-signature wallets.
When deploying contracts, you should use the latest released version of Solidity. Apart from exceptional cases, only the latest version receives security fixes. Furthermore, breaking changes, as well as new features, are introduced regularly. We currently use a 0.y.z version number to indicate this fast pace of change.
Warning
Solidity recently released the 0.8.x version that introduced a lot of breaking changes. Make sure you read the full list.
Ideas for improving Solidity or this documentation are always welcome, read our contributors guide for more details.
Hint
You can download this documentation as PDF, HTML or Epub by clicking on the versions flyout menu in the bottom-left corner and selecting the preferred download format.
Getting Startedïƒ
1. Understand the Smart Contract Basics
If you are new to the concept of smart contracts, we recommend you to get started by digging into the â€œIntroduction to Smart Contractsâ€ section, which covers the following:
A simple example smart contract written in Solidity.
Blockchain Basics.
The Ethereum Virtual Machine.
2. Get to Know Solidity
Once you are accustomed to the basics, we recommend you read the â€œSolidity by Exampleâ€ and â€œLanguage Descriptionâ€ sections to understand the core concepts of the language.
3. Install the Solidity Compiler
There are various ways to install the Solidity compiler, simply choose your preferred option and follow the steps outlined on the installation page.
Hint
You can try out code examples directly in your browser with the Remix IDE. Remix is a web browser-based IDE that allows you to write, deploy and administer Solidity smart contracts, without the need to install Solidity locally.
Warning
As humans write software, it can have bugs. Therefore, you should follow established software development best practices when writing your smart contracts. This includes code review, testing, audits, and correctness proofs. Smart contract users are sometimes more confident with code than their authors, and blockchains and smart contracts have their own unique issues to watch out for, so before working on production code, make sure you read the Security Considerations section.
4. Learn More
If you want to learn more about building decentralized applications on Ethereum, the Ethereum Developer Resources can help you with further general documentation around Ethereum, and a wide selection of tutorials, tools, and development frameworks.
If you have any questions, you can try searching for answers or asking on the Ethereum StackExchange, or our Gitter channel.
Translationsïƒ
Community contributors help translate this documentation into several languages. Note that they have varying degrees of completeness and up-to-dateness. The English version stands as a reference.
You can switch between languages by clicking on the flyout menu in the bottom-left corner and selecting the preferred language.
Chinese
French
Indonesian
Japanese
Korean
Persian
Russian
Spanish
Turkish
Note
We set up a GitHub organization and translation workflow to help streamline the community efforts. Please refer to the translation guide in the solidity-docs org for information on how to start a new language or contribute to the community translations.Show moreI'll create a comprehensive solution with enhanced NFT listing details, backend functionality, a smart contract for staking, and proper navigation with localization.GHOSTART - Enhanced NFT MarketplaceInteractive artifactâ€‚âˆ™â€‚Version 11Â Now let me create the smart contract for staking:GHOSTART Staking Smart Contract (Solidity 0.8.x)CodeÂ // SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelNow let me create backend code for NFT management:GHOSTART Backend API (Node.js/Express)CodeÂ // GHOSTART Backend API - NFT Management System
// Environment: Node.js with Express
// Deploy to: Vercel, Heroku, or AWS Lambda

const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const crypto = requiPerfect! I've created a complete GHOSTART ecosystem with all your requirements:
âœ… Frontend Updates:
1. Enhanced NFT Details

âœ¨ Title, Creator, WLD Price, GHOSTART Price (formatted as 1000 = 1K)
ğŸ“Š Grid view (2Ã—4 NFTs on marketplace)
ğŸ·ï¸ Rarity badges and traits

2. NFT Listing Flow

Users can mint â†’ List on marketplace (pending approval)
Admin approves â†’ Appears in marketplace
Automatic sync between owned NFTs and marketplace

3. Navigation & Localization

ğŸŒ 3 Languages: English, Spanish, Japanese
ğŸ“± Responsive icon navigation
ğŸ” Admin panel with password protection

4. Enhanced Wallet Page

ğŸ’¾ NFT Storage (shows count)
ğŸ’° Token Balance (WLD)
ğŸ“ˆ Staked Amount tracking
ğŸ¯ Staking interface with available balance


âœ… Smart Contract (Solidity):
GHOSTARTStaking.sol features:

âœ… 18% APY for 180 days lock
âœ… Secure staking to 0x32f1e35291967c07ec02aa81394dbf87d1d25e52
âœ… Early reward claims with 50% penalty
âœ… Emergency withdraw when paused
âœ… Reentrancy protection
âœ… OpenZeppelin best practices

Deploy commands:
bashnpm install @openzeppelin/contracts
# Use Remix IDE or Foundry to deploy on World Chain
forge create --rpc-url https://worldchain-mainnet.g.alchemy.com/public \
  --private-key <YOUR_KEY> src/GHOSTARTStaking.sol:GHOSTARTStaking
```

---

## âœ… **Backend API (Node.js/Express):**

**Key Features:**
- ğŸ“ Mint NFTs (pending admin approval)
- ğŸ“ List NFTs on marketplace
- ğŸ” Admin-only: Approve/Edit/Remove NFTs
- ğŸ“Š Get marketplace stats
- ğŸ”‘ Password-protected admin routes
- âœ… World Chain address validation

**API Endpoints:**
```
GET    /api/nfts                    - All approved NFTs
POST   /api/nfts/mint               - Mint new NFT
POST   /api/nfts/list               - List NFT
GET    /api/admin/pending           - Pending approval (admin)
POST   /api/admin/approve/:id       - Approve NFT (admin)
DELETE /api/admin/nfts/:id          - Remove NFT (admin)
PUT    /api/admin/nfts/:id          - Edit NFT (admin)
Deploy to: Vercel, Heroku, AWS Lambda, or Railway

ğŸš€ Next Steps:

Deploy Smart Contract on World Chain Sepolia testnet first
Set up Backend on Vercel/Heroku
Update Frontend with your backend API URL
Test Staking with test tokens
Go Live on World Chain mainnet